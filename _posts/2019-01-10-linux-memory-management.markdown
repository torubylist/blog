---
layout:     post
title:      "Linux内存管理概述"
subtitle:   " \"Hello World\""
date:       2019-01-10 21:00:00
author:     "木亘"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - Linux
    - 内存管理
---
# Linux内存管理

---
### 当我们聊Linux内存管理时，我们在聊什么
在linux下面，我们经常使用top,free等命令来查看系统的内存使用情况．那么我们经常看到的buff/cache,  swap等到底是什么意思呢？是我们说的电脑里面的内存比如4G或者8G么？他们是一回事么？带着这些疑问我们来看下文分解．

在上古时代，计算的物理内存大概只有128k,256k,1M这么大．但是你的计算机程序可能需要的内存是10M．这样你的需求和实际有巨大的落差，该怎么办呢？于是计算机先知们引出了虚拟内存的概念，就是说先给你分配10M虚拟内存，然后再把这些内存映射物理内存，延时分配，当你使用内存的时候再给你分配．而不是一开始就给你分配物理内存．这样我们只需要管理这10M的虚拟内存，让他能够映射到2M的物理内存上．并且不出现冲突．

所以讨论Linux下面的内存管理本质是讨论Linux下虚拟内存的实现方式．

### 虚拟内存是什么？
虚拟内存是Linux内存管理技术．它使得应用程序都认为自己拥有独立且连续的可用内存空间，而实际上，它通常被映射到多个物理内存段，可能还有部分映射到了物理磁盘上，在需要的时候再加载到内存当中来．

每个进程能够拥有的虚拟地址空间跟计算的cpu位数有关，在32位的系统中，虚拟内存空间大小是4G，内核空间分1G,用户空间分3G．而64的系统中，内核空间和用户空间各用128T，其余的未定义．当进程在内核态时，访问的是内核空间，当进程在用户态时，访问的是用户空间．虽然每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存，这样，进程切换到内核态后，就可以很方便的访问内核空间内存．虽然虚拟地址空间有4G，但是实际上物理内存可能远小于4G，因为我们的物理内存是按使用分配．

虚拟地址和进程息息相关，不同进程里的同一个虚拟地址指向的物理地址不一定不一样，如果一样，就能实现共享内存．所以离开进程谈虚拟内存没有任何意义．

### 虚拟内存和物理内存到底是什么关系呢？
谈了这么久虚拟内存，那么虚拟内存和物理内存到底是什么关系呢？下面这张图很好的表述了他俩的关系．

![虚拟地址和内存地址][1]

这样图里有几个新的概念比如页表，MMU等稍后再讲．

当进程执行一段程序时，需要先从内存读取该进程的指令，然后执行．获取指令时用到的内存就是指的虚拟地址，这个地址是程序链接时确定的（内核加载并初始化进程时会调整动态库的范围）．然后为了获取实际的物理数据，数据存在真正的物理内存里，所以CPU需要将物理地址转换成物理地址，CPU转换的时候就要用到页表(PageTable)，而页表里面的数据由操作系统维护．
> linux 内核代码访问内存时候用的都是实际的物理地址，所以不存在转换过程，只有应用程序才需要．

为了转换方便，linux将虚拟内存和物理内存都存拆分为固定大小的页，x86的系统一般内存页大小为4k,每页都会分配一个惟一的编号，及页编号（PFN）.

在上图中，虚拟内存和物理内存的页之间是通过页表来进行映射．这就是页表的作用．不同进程之间的虚拟内存是独立的，页表也是独立的．但是他们可以映射到同一块物理内存上．进程可以随时访问自己的虚拟内存，而页表和物理内存有内核维护，当进程需要访问内存时，CPU会根据进程的页表将虚拟地址翻译成内存地址．

那MMU又是做什么呢？MMU是CPU的一个模块，它就是用来存储页表，正常情况下，CPU就可以直接通过硬件，找出要访问的内存，这样比去访问内存要快的多．

> 注意：并不是每个虚拟地址空间的page都有对应的Page Table相关联，只有虚拟地址被分配给进程后，也即进程调用类似malloc函数之后，系统才会为相应的虚拟地址在Page Table中添加记录，如果进程访问一个没有和Page Table关联的虚拟地址，系统将会抛出SIGSEGV信号，导致进程退出，这也是为什么我们访问野指针时会经常出现segmentfault的原因。换句话说，虽然每个进程都有4G（32位系统）的虚拟地址空间，但只有向系统申请了的那些地址空间才能用，访问未分配的地址空间将会出segmentfault错误。Linux会将虚拟地址0不映射到任何地方，这样我们访问空指针就一定会报segmentfault错误。

### 页表是什么
页表可以简单理解为一个内存映射的链表，里面的每个映射都将一个虚拟内存地址映射到一个特定的资源（物理内存或者外部存储）．每个进程拥有自己的页表，和其他进程无关．
页的大小只有４KB，道德另一个问题就是页表会非常大．比如32位操作系统就有1million页表4GB/4KB,才能实现整个地址空间映射，为了解决这个问题，Linux提供了两种机制，大页和多级页表．

- 多级页表：多级页表就是把虚拟内存分成区块来管理，将原来的映射关系改成区块索引和区块内偏移．由于虚拟内存空间往往只使用了很少的一部分，那么多级页表就只保存这些使用的区块，从而减少页表的项数．
Linux使用的是四级页表来管理内存页．
![四级页表][2]

- 大页：就是比普通内存页更大的页，常见的有2MB和1GB．

### TLB 转译后备缓冲器
上文提到MMU中输入的是页表，而页表存咋跟cpu的cache相比，内存的速度很慢，所以为了加快查找速度，Linux发明了TLB，它存在于CPU的L1 cache里面，用来缓存已经找到的虚拟地址到物理地址的映射，这样下次转换前先查一下TLB，如果已经在里面了就不需要调用MMU了.

### 内存映射是怎么一回事
每个内存映射就是对一段虚拟内存的描述，包括虚拟地址的起始位置，长度，权限(比如这段内存里的数据是否可读、写、执行), 以及关联的资源(如物理内存页，swap空间上的page，磁盘上的文件内容等)。

内存映射通常包括两大类物理资源类型，分别是anonymous和file backed.他俩的主要差别就是当内存吃紧时，系统会直接删除掉file backed对应的物理内存，因为下次需要还能从磁盘读取出来，而anonymous page不能被删除，只能swap out.

1. anonymous：程序自己用到的数据段和堆栈空间，以及通过mmap分配的共享内存，它们在磁盘上找不到对应的文件，所以这部分内存页被叫做anonymous page

- shared：不同进程的页表里面多个内存映射可以映射到相同的物理内存，通过虚拟内存访问到相同的物理内存．这样就实现了共享内存，一般由mmap实现．当标记为shared的内存映射被删除回收时，需要更新物理内存页上的引用计数，便于物理页的计数为０时候回收内存．

- copy on write: copy on write基于shared技术，当读这种类型的内存时，系统不需要做任何特殊的操作，而当要写这块内存时，系统将会生成一块新的内存并拷贝原来内存中的数据到新内存中，然后将新内存关联到相应的memory mapping，然后执行写操作。

2. file backed:表示内存映射对应的物理资源存放在磁盘上的文件中，它所包含的信息包括文件的位置、offset、rwx权限等。当进程第一次访问对应的虚拟内存页的时候，由于在内存映射中找不到对应的物理内存，CPU会报缺页中断，然后操作系统就会处理这个中断并将文件的内容加载到物理内存中，然后更新内存映射，这样下次CPU就能访问这块虚拟地址了。以这种方式加载到内存的数据一般都会放到page cache中，关于page cache会在后面介绍到.
一般程序的可执行文件，动态库都是以这种方式映射到进程的虚拟地址空间的。

  - device backed:
    内存映射到了磁盘的物理地址，比如当物理内存被swap out后，将被标记为device backed。

### 访问控制
页表里面的每条映射记录都包涵一份控制信息，当进程要访问一块虚拟内存时，系统会根据控制信息来检测当前的操作是否合法．
为什么需要做这个检查呢？比如有些内存里面放的是程序的可执行代码，那么就不应该去修改它；有些内存里面存放的是程序运行时用到的数据，那么这部分内存只能被读写，不应该被执行；有些内存里面存放的是内核的代码，那么在用户态就不应该去执行它；有了这些检查之后会大大增强系统的安全性。

### 虚拟内存空间分布
我们主要关心的就是用户态内核空间分布，以32为操作系统为例．如图所示：
![虚拟内存分布][3]

- 只读段：包括代码和常量等
- 数据段：包括全局变量
- 堆：动态内存分配，从低地址到高地址增长
- 文件映射段：包括动态库，共享内存等，从高地址往下增长．
- 栈：局部变量和函数调用的上下文等，栈的大小树谷

在这五个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用C的标准库函数malloc()或者mmap(),就可以分别在堆和文件映射段分配内存．

### 内存的动态分配与回收
众所周知，malloc()是C标准库提供的动态内存分配函数，对应到系统调用上，有两种实现方式，brk()和mmap().

- 小块内存（小于128k）,使用brk()来分配．也就是通过移动堆顶的位置来分配内存．这些内存释放后并不会立刻归还系统，而是被缓存起来重复利用．
- 大块内存（大于128k）,直接使用内存映射mmap()来分配，也就是在文件映射段找一块空的内存分配出去．

> 我们要清楚的是，两种调用发生后，并没有真正分配内存，这些内存只有在首次访问时才分配，也就是通过缺页异常进入内核，再由内核分配内存．这就是延时加载．

brk()分配:
优点：由于缓存，可以减少缺页异常的发生，提高内存访问效率
缺点：这些内存并没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片．

mmap()分配:
优点：释放时直接归还系统．
缺点：在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大，这也是malloc()只对大块内存使用mmap的原因．

slab分配器：
如果遇到比页更小的对象，在内核中使用slab分配器来管理小内存，分配并释放内存中的小系统．

内存回收：
对内存来说，如果只分配而不释放，那么就会造成泄漏．甚至会耗尽内存．在应用程序中，使用完内存后还需要调用free(),unmap()来释放不使用的内存．
同时，内核在发现内存紧张时，就会通过一系列机制来回收内存．常见的有三种方式．

- 回收缓存，LRU,回收最近最少使用的内存页．LFU等．
- 回收不常使用的内存，把不常使用的内存数据通过交换分区直接写道磁盘中．swap out.swap存在严重的性能问题．只在内存不足的时候才会发生swap交换．
- 杀死进程，内存紧张时候系统通过OOM，直接杀掉占用大量内存的进程来回收内存．这是一种内核保护机制．

### 交换空间
当一个进程需要加载数据到物理内存中，但实际的物理内存已经被用完时，操作系统需要回收一些物理内存中的page以满足当前进程的需要。
对于file backed的内存数据，即物理内存里面的数据来自于磁盘上的文件，那么内核将直接将该部分数据从内存中移除掉来释放出更多的内存，当下次有进程需要访问这部分数据时，再将它从磁盘上加载到内存中来。但是，如果这部分数据被修改过且没被写入文件，那这部分数据就变成了脏数据，脏数据不能被直接删掉，只能被移动到交换空间上去。（可执行文件和动态库文件不会被修改，但通过mmap+private的方式映射到内存的磁盘文件有可能被修改，这种方式映射的内存比较特殊，没修改之前是file backed，修改后但没有写回磁盘之前就变成了anonymous的）

对于anonymous的内存数据，在磁盘上没有对应的文件，这部分数据不能直接被删除，而是被系统移到交换空间上去。交换空间就是磁盘上预留的一块特殊空间，被系统用来临时存放内存中不常被访问的数据，当下次有进程需要访问交换空间上的数据时，系统再将数据加载到内存中。由于交换空间在磁盘上，所以访问速度要比内存慢很多，频繁的读写交换空间会带来性能问题。

### 延时加载，按需分配
由于实际情况下物理内存要比虚拟内存少很多，所以操作系统必须很小心的分配物理内存，以使内存的使用率达到最大化。一个节约物理内存的办法就是只加载当前正在使用的虚拟page对应的数据到内存。

实现原理－当CPU访问一个虚拟内存页的时候，如果这个虚拟内存页对应的数据还没加载到物理内存中，则CPU就会通知操作系统发生了page fault，然后由操作系统负责将数据加载进物理内存。由于将数据加载进内存比较耗时，所以CPU不会等在那里，而是去调度其它进程，当它下次再调度到该进程时，数据已经在物理内存上了。

Linux主要使用这种方式来加载可执行文件和动态库，当程序被内核开始调度执行时，内核将进程的可执行文件和动态库映射到进程的虚拟地址空间，并只加载马上要用到的那小部分数据到物理内存中，其它的部分只有当CPU访问到它们时才去加载。

### 进程使用内存的过程
1. 进程向系统发出内存申请请求
2. 系统会检查进程的虚拟地址空间是否被用完，如果有剩余，给进程分配虚拟地址
3. 系统为这块虚拟地址创建相应的内存映射（可能多个），并将它放进该进程的页表
4. 系统返回虚拟地址给进程，进程开始访问该虚拟地址
5. CPU根据虚拟地址在该进程的页表中找到了相应的映射，但是该映射没有和物理内存关联，于是产生缺页中断
6. 操作系统收到缺页中断后，分配真正的物理内存并将它关联到相应的映射
7. 中断处理完成后，CPU就可以访问该内存了

### 查看内存使用情况
free是我们最常使用的命令之一
```
~ » free                                                                                                      
              total        used        free      shared  buff/cache   available
Mem:       12177592     8607184      722324     1232648     2848084     1828132
Swap:      12460028     4662332     7797696
```
默认以字节为单位．两行分别是物理内存和交换分区的使用情况．

- total:　总内存大小
- used: 已使用内存大小，包括共享内存
- free: 未使用内存大小
- shared: 共享内存大小
- buff/cache: 缓冲区和缓存的大小
- available:　新进程可用内存，不仅包括未使用内存，还包括了可回收的缓存．一般比未使用要大．

buff/cached代表了buff和cache总共用了多少，既会用在读请求，也会用在写请求．

- buff代表buffer cache占了多少空间，是对磁盘数据的缓存
- cache代表page cache和其它一些占用空间比较小且大小比较固定的cache的总和，基本上cache就约等于page cache，是文件数据的缓存．

磁盘数据和文件数据的区别：

- 磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录里面读写数据．
- 文件就是普通文件，磁盘是块设备．读写普通文件时，会经过文件系统，由文件系统和磁盘交互；而读写磁盘或者分区时，就会跳过文件系统，所谓的裸I/O.


top也是经常使用的．关注几个比较重要的数据．

- VIRT是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内．
- RES是常驻内存大小，就是进程实际使用的物理内存，不包括swap和共享内存．
- SHR共享内存大小，比如与其他进程共同使用的共享内存，加载的动态链接库和程序的代码段．
- ％MEM 即使用物理内存站系统总内存的百分比．

### Caches

为了提高系统性能，Linux使用了一些跟内存管理相关的cache，并且尽量将空闲的内存用于这些cache。这些cache都是系统全局共享的：

- Buffer Cache
用来缓冲块设备上的数据，比如磁盘，当读写块设备时，系统会将相应的数据存放到这个cache中，等下次再访问时，可以直接从cache中拿数据，从而提高系统效率。它里面的数据结构是一个块设备ID和block编号到具体数据的映射，只要根据块设备ID和块的编号，就能找到相应的数据。
- Page Cache
这个cache主要用来加快读写磁盘上文件的速度。它里面的数据结构是文件ID和offset到文件内容的映射，根据文件ID和offset就能找到相应的数据（这里文件ID可能是inode或者path，本人没有仔细去研究）。
从上面的定义可以看出，page cache和buffer cache有重叠的地方，不过实际情况是buffer cache只缓存page cache不缓存的那部分内容，比如磁盘上文件的元数据。所以一般情况下和page cache相比，Buffer Cache的大小基本可以忽略不计。

当然，使用cache也有一些不好的地方，比如需要时间和空间去维护cache，cache一旦出错，整个系统就挂了。





  [1]: https://time.geekbang.org/column/article/74272
  [2]: https://static001.geekbang.org/resource/image/b5/25/b5c9179ac64eb5c7ca26448065728325.png
  [3]: https://static001.geekbang.org/resource/image/71/5d/71a754523386cc75f4456a5eabc93c5d.png
  [4]: https://segmentfault.com/a/1190000008125006#articleHeader6