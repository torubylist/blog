---
layout:     post
title:      "[译]TCMalloc"
subtitle:   "TCMalloc内存分配器"
date:       2019-05-07 21:00:00
author:     "会飞的蜗牛"
header-img: "img/post-leaf-tcmalloc.jpg"
tags:
    - TCMalloc
    - 内存分配器
---

## Motivation（动机）
*TCMalloc*比*glibc 2.3 malloc*（被一个名叫ptmalloc2的独立库提供）和我测试的其他malloc更快。 *ptmalloc2*需要大约300ns才能在2.8 GHz的P4上执行malloc/free对（小对象）。 相同的操作下，*TCMalloc*实现大约需要花费50ns。 速度对于malloc实现很重要，因为如果malloc不够快，应用程序编写者倾向于在malloc之上编写自定义空闲列表。 这可能会导致额外的复杂性和更多的内存使用，除非应用程序编写者非常小心地调整空闲列表的大小并从空闲列表中清除空闲对象。

*TCMalloc*还减少了多线程程序的锁争用。 对于小型对象，几乎没有争用。 对于大型对象，*TCMalloc*尝试使用细粒度和高效的自旋锁来减少争用。 *ptmalloc2*还通过使用独立线程内存分配区来减少锁争用，但是*ptmalloc2*使用独立线程内存分配区存在很大问题， 在*ptmalloc2*中，内存永远不能在内存分配区之间转移，因为是独立的， 这可能会导致大量内存空间的浪费。 例如，在一个Google应用程序中，第一阶段将为其数据结构分配大约300MB的内存。 当第一阶段结束时，第二阶段将在同一地址空间中开始。 如果为第二阶段分配了与第一阶段完全不同的内存分配区，则该阶段将不会重用第一阶段之后剩余的任何内存，并且将向地址空间添加另外300MB。 在其他应用中也有类似的内存爆炸问题。

*TCMalloc*的另一个好处是高效的小对象内存表征。 例如，可以在使用大约8N * 1.01字节的空间的同时分配N个8字节对象。 即，百分之一的额外空间开销。 *ptmalloc2*为每个对象使用一个四字节的头，并且（我认为）将四舍五入为8个字节的倍数，最后将使用16N的字节。

## Usage（使用方法）
使用*TCmalloc*，只需通过“-ltcmalloc”链接器标志将```tcmalloc```链接到你的应用程序。

你可以在使用LD_PRELOAD编译的应用程序中使用tcmalloc：

```$ LD_PRELOAD =“/usr/lib/libtcmalloc.so”```

```LD_PRELOAD```很棘手，我们不推荐使用这种模式。

TCMalloc还包括[堆检查器](http://goog-perftools.sourceforge.net/doc/heap_checker.html)和[堆分析器](http://goog-perftools.sourceforge.net/doc/heap_profiler.html)。

如果你宁愿链接一个不包含堆分析器和检查器的TCMalloc版本（也许是为了减少静态二进制文件的二进制大小），你可以在```libtcmalloc_minimal```中进行链接。

## Overview（概述）
*TCMalloc*为每个线程分配本地缓存。线程本地缓存满足小分配。 根据需要将对象从中央数据结构移动到线程本地缓存中，并使用周期性的垃圾收集将内存从线程本地缓存迁移回到中央数据结构。

![此处输入图片的描述][1]

*TCMalloc*对小对象（<=32KB）的分配跟大对象不同，大对象直接由中央堆使用页级（页是在内存中是4KB）分配器分配，所以，大对象是页对齐的，并且占据整数个页。

一连串的页会被切分成连续的大小相等的小对象，例如，一页（4KB）会被切分成32个128B大小的对象。

## Small Object Allocation（小对象分配）
每个小对象映射到大约170个可分配大小类中的一个。 例如，961到1024字节范围内的所有对象都会向上舍入到1024.大小类间隔开，以便小尺寸分隔8个字节，较大尺寸分隔16个字节，更大尺寸分隔为32个字节，依此类推。 最大间距（对于大小>=~2K）是256个字节。
线程缓存包含每种size-class空闲对象的单个列表。

![此处输入图片的描述][2]

分配小对象时：

1. 我们将其大小映射到相应的大小类。
2. 查看当前线程的线程缓存中的相应空闲列表。
3. 如果空闲列表不为空，我们从列表中删除第一个对象并将其返回。
遵循此快速路径时，TCMalloc根本不会获取任何锁定。这显著地加速了内存分配，因为一次锁定/解锁在2.8 GHz Xeon上大约需要100ns。
如果空闲列表为空：
1. 我们从这个大小类的中央空闲列表中获取一堆对象（所有线程共享中央空闲列表）。
2. 将它们放在线程本地空闲列表中。
3. 将一个新获取的对象返回给应用程序。

如果中央空闲列表也是空的：
1. 我们从中央页分配器分配一系列页。
2. 将上述页分成这个size-class的一组对象。
3. 将新对象放在中央空闲列表中。
4. 和之前一样，将其中一些对象移动到线程本地空闲列表中。

## Large Object Allocation（大对象分配）
大对象大小（> 32K）向上舍入到内存页大小（4K）的倍数并由中央内存页堆处理。中央内存页堆也是一个空闲列表数组。 对于i <256，第k个条目是由k个页面组成的运行的空闲列表。 第256个条目是长度>=256页的空闲列表：

![此处输入图片的描述][3]

通过查看第k个空闲列表来满足k页的分配。 如果该空闲列表为空，我们将查看下一个空闲列表，依此类推。 最后，如有必要，我们会查看最后一个空闲列表。 如果全部都不满足，我们就会从操作系统中获取内存（使用sbrk，mmap或在/dev/mem里做部分映射）。

如果长度>k的内存页页运行满足k页的分配，则该内存页的其余部分将重新插入页堆相应的空闲列表中。

## Spans（范围）
由TCMalloc管理的堆由一组内存页组成。这些连续内存页由Span对象表示。一个span可以是已分配的，也可以是空闲的。如果是空闲的，则span是页堆链表中的条目之一。 如果已分配，要么它是已分配给应用程序的大对象，要么就是被分割为一系列小对象的一组内存页。 如果是拆分为小对象，则对象的size-class记录在span中。

![此处输入图片的描述][4]

可以使用由页码索引的中央数组来查找内存页所属的span。 例如，span a占用2页，span b占1页，span c占5页，span d占3页。

32位地址空间可以容纳2^20个内存页（4KB），因此这个中央数组需要4MB的空间，这似乎还可以接受。 在64位计算机上，我们使用3级基数树而不是数组来从页码映射到相应的span指针。

## Deallocation（释放）
当一个对象被释放时，我们将计算其页数并在中心数组中通过它查找到相应的span对象。

span将会告诉我们对象的大小。

1. 如果是小对象，返回它的size-class，并将它插入当前线程的本地缓存中相应的空闲列表中。如果线程本地缓存超过了预定大小（默认为2MB），我们运行垃圾收集器，将未使用的对象从线程缓存回收到中央空闲列表中。

2. 如果是大对象，span会告诉我们对象覆盖的内存页范围。 假设这个范围是[p，q]。 我们还得查找页面p-1和q + 1的span。 如果这些相邻span中的都是空闲的，我们就将它们与[p，q]合并。生成新的span将插入页堆中相应的空闲列表中。

### Central Free Lists for Small Objects
如前所述，我们为每个size-class保留一个中央空闲列表。 每个中央空闲列表都由为两级数据结构组成：一组spans和每个span的空闲对象的链表。

中央空闲列表通过从某个span的链表中删除第一个条目来分配对象。（如果所有的spans的链表都是空的，则首先从中央页堆中分配适当大小的spans。）

通过将对象添加到其所属span的链接列表，将对象返回到中央空闲列表。 如果链表长度等于spans中的小对象总数，则此span现在完全空闲的，这样就将其归还到内存页堆中。

## Garbage Collection of Thread Caches
当缓存中所有对象的总大小超过2MB时，将对线程缓存进行垃圾收集。随着线程数量的增加，垃圾收集阈值会自动降低，这样我们就不会在具有大量线程的程序中浪费过多的内存。

我们遍历缓存中的所有空闲列表，并将一些对象从空闲列表移动到相应的中央列表。

我们使用每列表低水位标记L确定要从空闲列表移动的对象的数量。 L记录自上次垃圾收集以来列表的最小长度。请注意，我们可以在最后一次垃圾收集时通过L对象缩短列表，且无需对中央列表进行任何的额外访问。我们使用过去的历史作为未来访问的预测器，并将L/2个对象从线程缓存空闲列表移动到相应的中央空闲列表。该算法具有良好的属性，如果线程停止使用某个特定大小的对象，则该大小的所有对象将快速从线程高速缓存移动到中央空闲列表，这样其他线程就可以使用它们了。

## References
[TCMalloc : Thread-Caching Malloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)


  [1]: http://goog-perftools.sourceforge.net/doc/overview.gif
  [2]: http://goog-perftools.sourceforge.net/doc/threadheap.gif
  [3]: http://goog-perftools.sourceforge.net/doc/pageheap.gif
  [4]: http://goog-perftools.sourceforge.net/doc/spanmap.gif